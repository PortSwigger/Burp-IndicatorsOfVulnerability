/*
 * Name:           Burp Indicators of Vulnerability
 * Version:        0.1.8
 * Date:           1/9/2019
 * Author:         Josh Berry - josh.berry@codewatch.org
 * Github:         https://github.com/codewatchorg/Burp-IndicatorsOfVulnerability
 * 
 * Description:    This plugin checks application responses and in some cases browser requests for indications of SQLi, XXE, and other vulnerabilities or attack points for these issues.
 * 
 * Contains regex work from SecretsFinder by m4110k: https://github.com/m4ll0k/BurpSuite-Secret_Finder
 *
*/

package burp;

import java.util.List;
import java.util.ArrayList;
import java.io.PrintWriter;
import java.net.URL;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class BurpExtender implements IBurpExtender, IHttpListener {

  // Setup extension wide variables
  public IBurpExtenderCallbacks extCallbacks;
  public IExtensionHelpers extHelpers;
  private static final String burpIVVersion = "0.1.8";
  private static final Pattern SqlPattern = Pattern.compile("(SQL Server|MySQL|MariaDB|Postgres|Oracle|ORA\\-[0-9][0-9]|OLE DB Provider|JET Database|Type mismatch|error in your SQL|Invalid SQL|OLEDB Exception|ADODB|OLEDB Provider|OleDbException|ODBC)", Pattern.CASE_INSENSITIVE);
  private static final Pattern SqlParamPattern = Pattern.compile("(row|table|select|delete|update|insert|column|field|from|to|keyword|search|query|sort|sel|select|sort|where)", Pattern.CASE_INSENSITIVE);
  private static final Pattern XxePattern = Pattern.compile("(XML Reader error|java\\.xml\\.|UnmarshalException|Marshaller|Xml\\.XmlDocument|Xml\\.XmlDictionaryReader|Xml\\.XmlNodeReader|Xml\\.XmlReader|Xml\\.XmlTextReader|Xml\\.Xpath\\.XpathNavigator|Xsl\\.XslCompiledTransform|System\\.Xml|org\\.xml\\.|sax\\.XMLReader|DocumentBuilderFactory|SAXParserFactory|DOM4J|XmlInputFactory|TransformerFactory|validation\\.Validator|validation\\.SchemaFactory|SAXTransformerFactory)", Pattern.CASE_INSENSITIVE);
  private static final Pattern CgiPattern = Pattern.compile("(/cgi-bin/|/cgi-sys/|/cgi-mod/|[a-zA-Z0-9]*\\.cgi)", Pattern.CASE_INSENSITIVE);
  private static final Pattern CmdPattern = Pattern.compile("(exec|shell|run|cmd)", Pattern.CASE_INSENSITIVE);
  private static final Pattern SerialPattern = Pattern.compile("(serialize\\(\\),marshal\\.load|marshal\\.dump|unpickler|cpickle|ObjectInputStream\\.readUnshared|XStream\\.fromXML|XMLDecoder|ObjectInputStream\\.readObject|ObjectInputStream\\.defaultReadObject|LocateRegistry\\.createRegistry|Serialization\\.XmlSerializer|Serialization\\.DataContractSerializer|Serialization\\.NetDataContractSerializer|Serialization\\.JavaScriptSerializer|Serialization\\.Json\\.DataContractJsonSerializer|System\\.Resource\\.ResourceReader|Microsoft\\.Web\\.Design\\.Remote\\.ProxyObject|Newtonsoft\\.Json\\.JsonSerializationException|ServiceStack\\.Text|Binary\\.BinaryFormatter|Soap\\.SoapFormatter|UI\\.ObjectStateFormatter|Serialization\\.NetDataContractSerializer|UI\\.LosFormatter|Workflow\\.ComponentModel\\.Activity|SoapServerFormatterSinkProvider|SoapClientFormatterSinkProvider|BinaryServerFormatterSinkProvider|BinaryClientFormatterSinkProvider|SoapClientFormatterSink|SoapServerFormatterSink|BinaryClientFormatterSink|BinaryServerFormatterSink)", Pattern.CASE_INSENSITIVE);
  private static final Pattern SuspiciousPattern = Pattern.compile("(cfg|^conf$|config|dbg|debug|clone|enable|toggle|disable|load)", Pattern.CASE_INSENSITIVE);
  private static final Pattern SerialHeaderPattern = Pattern.compile("(x-java-serialized-object)");
  private static final Pattern FileHandlingPattern = Pattern.compile("(^doc$|document|callback|^dir$|directory|^dest$|destination|html|domain|host|navigation|next|view|site|page|^pdf$|style|template|folder|^redir$|redirect|url|path|return|^file$|^image$|imagename|open|filename)", Pattern.CASE_INSENSITIVE);
  private static final Pattern IdorHandlingPattern = Pattern.compile("(edit|modify|[a-zA-Z0-9]id|^id$|group|user|order|number|^num$|account|key)", Pattern.CASE_INSENSITIVE);
  private static final Pattern SecretsPattern = Pattern.compile("(azure_storage_account|AZURE_STORAGE_ACCOUNT|azure_storage_access_key|AZURE_STORAGE_ACCESS_KEY|S3_KEY|S3_SECRET|AWS_ACCESS_KEY_ID|AWS_SECRET_ACCESS_KEY|AccessKeyId|SecretAccessKey|aws_access_key_id|aws_secret_access_key|aws_session_token|s3_key|s3_secret|accesskeyid|secretaccesskey|BEGIN RSA PRIVATE KEY|BEGIN DSA PRIVATE KEY|BEGIN EC PRIVATE KEY|BEGIN PGP PRIVATE KEY BLOCK|AIza[0-9A-Za-z-_]{35}|6L[0-9A-Za-z-_]{38}|ya29\\.[0-9A-Za-z\\-_]+|A3T[A-Z0-9]|AKIA[0-9A-Z]{16}|ASIA[0-9A-Z]{16}|AGPA[A-Z0-9]{16}|AIDA[A-Z0-9]{16}|AROA[A-Z0-9]{16}|AIPA[A-Z0-9]{16}|ANPA[A-Z0-9]{16}|ANVA[A-Z0-9]{16}|amzn\\\\.mws\\\\.[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|EAACEdEose0cBA[0-9A-Za-z]+|key-[0-9a-zA-Z]{32}|SK[0-9a-fA-F]{32}|AC[a-zA-Z0-9_\\-]{32}|AP[a-zA-Z0-9_\\-]{32}|access_token\\$production\\$[0-9a-z]{16}\\$[0-9a-f]{32}|sq0csp-[ 0-9A-Za-z\\-_]{43}|sqOatp-[0-9A-Za-z\\-_]{22}|sk_live_[0-9a-zA-Z]{24}|rk_live_[0-9a-zA-Z]{24}|[a-zA-Z0-9_-]*:[a-zA-Z0-9_\\-]+@github\\.com*)");
  private static final Pattern S3BucketPattern = Pattern.compile("((?:\\w+://)?(?:([\\w.-]+)\\.s3[\\w.-]*\\.amazonaws\\.com|s3(?:[\\w.-]*\\.amazonaws\\.com(?:(?::\\d+)?\\\\?/)*|://)([\\w.-]+))(?:(?::\\d+)?\\\\?/)?(?:.*?\\?.*Expires=(\\d+))?)", Pattern.CASE_INSENSITIVE);
  private static final Pattern GoogleBucketPattern = Pattern.compile("((?:\\w+://)?(?:([\\w.-]+)\\.storage[\\w-]*\\.googleapis\\.com|(?:(?:console\\.cloud\\.google\\.com/storage/browser/|storage[\\w-]*\\.googleapis\\.com)(?:(?::\\d+)?\\\\?/)*|gs://)([\\w.-]+))(?:(?::\\d+)?\\\\?/([^\\s?#]*))?(?:.*\\?.*Expires=(\\d+))?)", Pattern.CASE_INSENSITIVE);
  private static final Pattern AzureBucketPattern = Pattern.compile("(([\\w.-]+\\.blob\\.core\\.windows\\.net(?::\\d+)?\\\\?/[\\w.-]+)(?:.*?\\?.*se=([\\w%-]+))?)", Pattern.CASE_INSENSITIVE);

  private PrintWriter printOut;

  // Basic extension setup
  @Override
  public void registerExtenderCallbacks(IBurpExtenderCallbacks callbacks) {
    extCallbacks = callbacks;
    extHelpers = extCallbacks.getHelpers();
    extCallbacks.setExtensionName("Indicators of Vulnerability");
    printOut = new PrintWriter(extCallbacks.getStdout(), true);
    extCallbacks.registerHttpListener(this);
    printHeader();    
  }
  
  // Print to extension output tab
  public void printHeader() {
    printOut.println("Indicators of Vulnerability: " + burpIVVersion + "\n====================\nMonitor requests and responses for common indicators of SQLi, CMDi, XXE, Serialization, SSRF, LFI, RFI, and Directory Traversal issues.\n\n"
      + "josh.berry@codewatch.org\n\n");
  }
  
  // Process requests and responses and look for specified content
  @Override
  public void processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo) {
    // Only process requests if the URL is in scope
    if (extCallbacks.isInScope(extHelpers.analyzeRequest(messageInfo).getUrl())) {
    
      // Process checks in the request
      if (messageIsRequest) {
        // Setup default request variables for URL and body
        IRequestInfo requestInfo = extHelpers.analyzeRequest(messageInfo);
        String reqUrl = requestInfo.getUrl().toString();
        String reqRaw = new String(messageInfo.getRequest());
        String reqBody = reqRaw.substring(requestInfo.getBodyOffset());
        List<String> headers = requestInfo.getHeaders();
      
        // Create patter matchers for each type
        Matcher CgiUrlMatch = CgiPattern.matcher(reqUrl);
        Matcher S3BucketUrlMatch = S3BucketPattern.matcher(reqUrl);
        Matcher S3BucketBodyMatch = S3BucketPattern.matcher(reqBody);
        Matcher GoogleBucketUrlMatch = GoogleBucketPattern.matcher(reqUrl);
        Matcher GoogleBucketBodyMatch = GoogleBucketPattern.matcher(reqBody);
        Matcher AzureBucketUrlMatch = AzureBucketPattern.matcher(reqUrl);
        Matcher AzureBucketBodyMatch = AzureBucketPattern.matcher(reqBody);
      
        // Check headers for indicators
        for (int i = 0; i < headers.size(); i++) {
        
          // Match against serialized object
          Matcher SerialHeaderMatch = SerialHeaderPattern.matcher(headers.get(i));
        
          if (SerialHeaderMatch.find()) {
            List<int[]> SerialHeaderMatches = getMatches(messageInfo.getRequest(), SerialHeaderMatch.group(0).getBytes());
            reportIssue(messageInfo, SerialHeaderMatches, "[IoV] Serialization Indicator of Vulnerability", "The request contained the following header: " + SerialHeaderMatch.group(0), "Information", "Tentative");
          }
        }
      
        // Check Parameters for potential targets of attack
        for (IParameter parameter : requestInfo.getParameters()) {
          Matcher FileParamMatch = FileHandlingPattern.matcher(parameter.getName());
          Matcher CmdParamMatch = CmdPattern.matcher(parameter.getName());
          Matcher SuspiciousParamMatchName = SuspiciousPattern.matcher(parameter.getName());
          Matcher SuspiciousParamMatchValue = SuspiciousPattern.matcher(parameter.getValue());
          Matcher IdorParamMatch = IdorHandlingPattern.matcher(parameter.getName());
          Matcher SqlParamMatch = SqlParamPattern.matcher(parameter.getName());
      
          // Create an issue if we match any of the potential sources of attack for
          // SSRF / LFI / RFI / Directory Traversal / URL injection. These are areas to focus
          // these attacks, not confirmed vulnerabilities.
          if (FileParamMatch.find()) {
            List<int[]> FileParamMatches = getMatches(messageInfo.getRequest(), FileParamMatch.group(0).getBytes());
            reportIssue(messageInfo, FileParamMatches, "[IoV] Target for SSRF/LFI/RFI/URLi/DirTraversal", "The request contained the following potential target parameter: " + FileParamMatch.group(0), "Information", "Tentative");
          }
        
          // Check for parameters indicative of being vulnerable to CMDi
          if (CmdParamMatch.find()) {
            List<int[]> CmdParamMatches = getMatches(messageInfo.getRequest(), CmdParamMatch.group(0).getBytes());
            reportIssue(messageInfo, CmdParamMatches, "[IoV] Target for CMDi", "The request contained the following potential target parameter: " + CmdParamMatch.group(0), "Information", "Tentative");
          }
        
          // Check for parameters that are suspicious
          if (SuspiciousParamMatchName.find()) {
            List<int[]> SuspiciousParamMatches = getMatches(messageInfo.getRequest(), SuspiciousParamMatchName.group(0).getBytes());
            reportIssue(messageInfo, SuspiciousParamMatches, "[IoV] Suspicious Parameters to Target", "The request contained the following potential target parameter: " + SuspiciousParamMatchName.group(0), "Information", "Tentative");
          }
        
          if (SuspiciousParamMatchValue.find()) {
            List<int[]> SuspiciousParamMatches = getMatches(messageInfo.getRequest(), SuspiciousParamMatchValue.group(0).getBytes());
            reportIssue(messageInfo, SuspiciousParamMatches, "[IoV] Suspicious Parameters to Target", "The request contained the following potential target parameter: " + SuspiciousParamMatchValue.group(0), "Information", "Tentative");
          }
        
          // Check for parameters indicative of being vulnerable to IDOR
          if (IdorParamMatch.find()) {
            if (parameter.getValue().matches("^[0-9].*")) {
              List<int[]> IdorParamMatches = getMatches(messageInfo.getRequest(), IdorParamMatch.group(0).getBytes());
              reportIssue(messageInfo, IdorParamMatches, "[IoV] Target for IDOR", "The request contained the following potential target parameter: " + IdorParamMatch.group(0), "Information", "Tentative");
            }
          }
        
          // Check for parameters indicative of being vulnerable to IDOR
          if (SqlParamMatch.find()) {
            List<int[]> SqlParamMatches = getMatches(messageInfo.getRequest(), SqlParamMatch.group(0).getBytes());
            reportIssue(messageInfo, SqlParamMatches, "[IoV] Target for SQLi", "The request contained the following potential target parameter: " + SqlParamMatch.group(0), "Information", "Tentative");
          }
        }
      
        // Create an issue if we match any of the potential sources of attack for
        // CMDi a-la ShellShock. More to be added later. These are areas to focus these attacks,
        // not confirmed vulnerabilities.
        if (CgiUrlMatch.find()) {
          List<int[]> CgiUrlMatches = getMatches(messageInfo.getRequest(), CgiUrlMatch.group(0).getBytes());
          reportIssue(messageInfo, CgiUrlMatches, "[IoV] Target for ShellShock CMDi", "The URL contained the following path/file: " + CgiUrlMatch.group(0), "Information", "Tentative");
        }
        
        // Create an issue noting an AWS S3 Bucket was identified in the URL
        if (S3BucketUrlMatch.find()) {
          List<int[]> S3BucketUrlMatches = getMatches(messageInfo.getRequest(), S3BucketUrlMatch.group(0).getBytes());
          reportIssue(messageInfo, S3BucketUrlMatches, "[IoV] AWS S3 Bucket Identified", "The URL contained the following bucket: " + S3BucketUrlMatch.group(0), "Information", "Firm");
        }
        
        // Create an issue noting a Google Bucket was identified in the URL
        if (GoogleBucketUrlMatch.find()) {
          List<int[]> GoogleBucketUrlMatches = getMatches(messageInfo.getRequest(), GoogleBucketUrlMatch.group(0).getBytes());
          reportIssue(messageInfo, GoogleBucketUrlMatches, "[IoV] Google Storage Bucket Identified", "The URL contained the following bucket: " + GoogleBucketUrlMatch.group(0), "Information", "Firm");
        }

        // Create an issue noting an Azure Bucket was identified in the URL
        if (AzureBucketUrlMatch.find()) {
          List<int[]> AzureBucketUrlMatches = getMatches(messageInfo.getRequest(), AzureBucketUrlMatch.group(0).getBytes());
          reportIssue(messageInfo, AzureBucketUrlMatches, "[IoV] Azure Storage Container Identified", "The URL contained the following bucket: " + AzureBucketUrlMatch.group(0), "Information", "Firm");
        }
        
        // Create an issue noting an AWS S3 Bucket was identified in the request
        if (S3BucketBodyMatch.find()) {
          List<int[]> S3BucketBodyMatches = getMatches(messageInfo.getRequest(), S3BucketBodyMatch.group(0).getBytes());
          reportIssue(messageInfo, S3BucketBodyMatches, "[IoV] AWS S3 Bucket Identified", "The request body contained the following bucket: " + S3BucketBodyMatch.group(0), "Information", "Firm");
        }
        
        // Create an issue noting a Google Bucket was identified in the request
        if (GoogleBucketBodyMatch.find()) {
          List<int[]> GoogleBucketBodyMatches = getMatches(messageInfo.getRequest(), GoogleBucketBodyMatch.group(0).getBytes());
          reportIssue(messageInfo, GoogleBucketBodyMatches, "[IoV] Google Storage Bucket Identified", "The request body contained the following bucket: " + GoogleBucketBodyMatch.group(0), "Information", "Firm");
        }

        // Create an issue noting an Azure Bucket was identified in the request
        if (AzureBucketBodyMatch.find()) {
          List<int[]> AzureBucketBodyMatches = getMatches(messageInfo.getRequest(), AzureBucketBodyMatch.group(0).getBytes());
          reportIssue(messageInfo, AzureBucketBodyMatches, "[IoV] Azure Storage Container Identified", "The request body contained the following bucket: " + AzureBucketBodyMatch.group(0), "Information", "Firm");
        }
      
      // Process checks in the response
      } else {
        // Setup default response body variable
        IRequestInfo requestInfo = extHelpers.analyzeRequest(messageInfo);
        String respRaw = new String(messageInfo.getResponse());
        String respBody = respRaw.substring(extHelpers.analyzeResponse(messageInfo.getResponse()).getBodyOffset());
        List<String> headers = requestInfo.getHeaders();
      
        // Create patter matchers for each type
        Matcher XxeMatch = XxePattern.matcher(respBody);
        Matcher SqlMatch = SqlPattern.matcher(respBody);
        Matcher SerialMatch = SerialPattern.matcher(respBody);
        Matcher SecretsMatch = SecretsPattern.matcher(respBody);
        Matcher S3BucketMatch = S3BucketPattern.matcher(respBody);
        Matcher GoogleBucketMatch = GoogleBucketPattern.matcher(respBody);
        Matcher AzureBucketMatch = AzureBucketPattern.matcher(respBody);
      
        // Create an issue if we match any of the indicators for XXE vulnerabilities
        if (XxeMatch.find()) {
          List<int[]> XxeMatches = getMatches(messageInfo.getResponse(), XxeMatch.group(0).getBytes());
          reportIssue(messageInfo, XxeMatches, "[IoV] XXE Indicator of Vulnerability", "The response contained the following text: " + XxeMatch.group(0), "Low", "Tentative");
        }
      
        // Create an issue if we match any of the indicators for SQLi vulnerabilities
        if (SqlMatch.find()) {
          List<int[]> SqlMatches = getMatches(messageInfo.getResponse(), SqlMatch.group(0).getBytes());
          reportIssue(messageInfo, SqlMatches, "[IoV] SQLi Indicator of Vulnerability", "The response contained the following text: " + SqlMatch.group(0), "Low", "Tentative");
        }
      
        // Create an issue if we match any of the indicators for Deserialization vulnerabilities
        if (SerialMatch.find()) {
          List<int[]> SerialMatches = getMatches(messageInfo.getResponse(), SerialMatch.group(0).getBytes());
          reportIssue(messageInfo, SerialMatches, "[IoV] Serialization Indicator of Vulnerability", "The response contained the following text: " + SerialMatch.group(0), "Low", "Tentative");
        }
      
        // Create an issue if we match any potential secrets
        if (SecretsMatch.find()) {
          List<int[]> SecretsMatches = getMatches(messageInfo.getResponse(), SecretsMatch.group(0).getBytes());
          reportIssue(messageInfo, SecretsMatches, "[IoV] Leaked Secrets Indicator of Vulnerability", "The response contained the following text: " + SecretsMatch.group(0), "Medium", "Tentative");
        }
        
        // Create an issue noting an AWS S3 Bucket was identified in the response
        if (S3BucketMatch.find()) {
          List<int[]> S3BucketMatches = getMatches(messageInfo.getResponse(), S3BucketMatch.group(0).getBytes());
          reportIssue(messageInfo, S3BucketMatches, "[IoV] AWS S3 Bucket Identified", "The response body contained the following bucket: " + S3BucketMatch.group(0), "Information", "Firm");
        }
        
        // Create an issue noting a Google Bucket was identified in the response
        if (GoogleBucketMatch.find()) {
          List<int[]> GoogleBucketMatches = getMatches(messageInfo.getResponse(), GoogleBucketMatch.group(0).getBytes());
          reportIssue(messageInfo, GoogleBucketMatches, "[IoV] Google Storage Bucket Identified", "The response body contained the following bucket: " + GoogleBucketMatch.group(0), "Information", "Firm");
        }

        // Create an issue noting an Azure Bucket was identified in the response
        if (AzureBucketMatch.find()) {
          List<int[]> AzureBucketMatches = getMatches(messageInfo.getResponse(), AzureBucketMatch.group(0).getBytes());
          reportIssue(messageInfo, AzureBucketMatches, "[IoV] Azure Storage Container Identified", "The response body contained the following bucket: " + AzureBucketMatch.group(0), "Information", "Firm");
        }
      
        // Check headers for indicators
        for (int i = 0; i < headers.size(); i++) {
    
          // Match against serialized object
          Matcher SerialHeaderMatch = SerialHeaderPattern.matcher(headers.get(i));
        
          if (SerialHeaderMatch.find()) {
            List<int[]> SerialHeaderMatches = getMatches(messageInfo.getRequest(), SerialHeaderMatch.group(0).getBytes());
            reportIssue(messageInfo, SerialHeaderMatches, "[IoV] Serialization Indicator of Vulnerability", "The request contained the following header: " + SerialHeaderMatch.group(0), "Information", "Tentative");
          }
        }
      }
    }
  }
  
  // helper method to search a response for occurrences of a literal match string
  // and return a list of start/end offsets
  private List<int[]> getMatches(byte[] response, byte[] match) {
    List<int[]> matches = new ArrayList<int[]>();

    int start = 0;
    while (start < response.length) {
      start = extHelpers.indexOf(response, match, true, start, response.length);
      if (start == -1)
        break;
      matches.add(new int[] { start, start + match.length });
      start += match.length;
    }
        
    return matches;
  }
  
  // Create issues from the reported findings
  private IScanIssue reportIssue(IHttpRequestResponse baseRequestResponse, List<int[]>matches, String IssueName, String IssueMatch, String Severity, String Confidence) {
      IScanIssue issue = new CustomScanIssue(
          baseRequestResponse.getHttpService(),
          extHelpers.analyzeRequest(baseRequestResponse).getUrl(), 
          new IHttpRequestResponse[] { extCallbacks.applyMarkers(baseRequestResponse, null, matches) }, 
          IssueName,
          IssueMatch,
          Severity,
          Confidence
      );

      String issueUrl = extHelpers.analyzeRequest(baseRequestResponse).getUrl().getProtocol() + "://" + extHelpers.analyzeRequest(baseRequestResponse).getUrl().getHost() + extHelpers.analyzeRequest(baseRequestResponse).getUrl().getPath();
      IScanIssue issues[] = extCallbacks.getScanIssues(issueUrl);
      int ReportMatch = 0;

      if (issues.length >= 1) {
        for (int i=0; i<issues.length;i++) { 
          if (issues[i].getIssueName().equals(IssueName)) {
            ReportMatch = 1;
          }
        }
        
        if (ReportMatch == 0) {
          extCallbacks.addScanIssue(issue);
        }
      } else {
        extCallbacks.addScanIssue(issue);
      }

      return issue;
  }
}

class CustomScanIssue implements IScanIssue {
  private IHttpService httpService;
  private URL url;
  private IHttpRequestResponse[] httpMessages;
  private String name;
  private String detail;
  private String severity;
  private String confidence;

  public CustomScanIssue(IHttpService httpService, URL url, IHttpRequestResponse[] httpMessages, String name, String detail, String severity, String confidence) {
    this.httpService = httpService;
    this.url = url;
    this.httpMessages = httpMessages;
    this.name = name;
    this.detail = detail;
    this.severity = severity;
    this.confidence = confidence;
  }
    
  @Override
  public URL getUrl() {
    return url;
  }

  @Override
  public String getIssueName() {
    return name;
  }

  @Override
  public int getIssueType() {
    return 0;
  }

  @Override
  public String getSeverity() {
    return severity;
  }

  @Override
  public String getConfidence() {
    return confidence;
  }

  @Override
  public String getIssueBackground() {
    return null;
  }

  @Override
  public String getRemediationBackground() {
    return null;
  }

  @Override
  public String getIssueDetail() {
    return detail;
  }

  @Override
  public String getRemediationDetail() {
    return null;
  }

  @Override
  public IHttpRequestResponse[] getHttpMessages() {
    return httpMessages;
  }

  @Override
  public IHttpService getHttpService() {
    return httpService;
  }
}