/*
 * Name:           Burp Indicators of Vulnerability
 * Version:        0.2.6
 * Date:           1/9/2020
 * Author:         Josh Berry - josh.berry@codewatch.org
 * Github:         https://github.com/codewatchorg/Burp-IndicatorsOfVulnerability
 * 
 * Description:    This plugin checks application responses and in some cases browser requests for indications of SQLi, XXE, and other vulnerabilities or attack points for these issues.
 * 
 * Contains regex work from SecretsFinder by m4110k: https://github.com/m4ll0k/BurpSuite-Secret_Finder
 *
*/

package burp;

import java.util.List;
import java.util.ArrayList;
import java.io.PrintWriter;
import java.net.URL;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.File;
import java.util.Arrays;
import java.io.Reader;
import java.io.StringReader;

public class BurpExtender implements IBurpExtender, IScannerCheck, IHttpListener {

  // Setup extension wide variables
  public IBurpExtenderCallbacks extCallbacks;
  public IExtensionHelpers extHelpers;
  private static final String burpIVVersion = "0.2.6";
  private static final Pattern SqlPattern = Pattern.compile("(SQL Server|MySQL|MariaDB|Postgres|Oracle|ORA\\-[0-9][0-9]|OLE DB Provider|JET Database|Type mismatch|error in your SQL|Invalid SQL|OLEDB Exception|ADODB|OLEDB Provider|OleDbException|ODBC)", Pattern.CASE_INSENSITIVE);
  private static final Pattern SqlParamPattern = Pattern.compile("(row|table|grant|create|select|alter|delete|update|insert|column|field|^from|^to$|keyword|search|results|filter|sleep|fetch|query|sort|^sel$|select|where)", Pattern.CASE_INSENSITIVE);
  private static final Pattern XxePattern = Pattern.compile("(XML Reader error|java\\.xml\\.|UnmarshalException|Marshaller|Xml\\.XmlDocument|Xml\\.XmlDictionaryReader|Xml\\.XmlNodeReader|Xml\\.XmlReader|Xml\\.XmlTextReader|Xml\\.Xpath\\.XpathNavigator|Xsl\\.XslCompiledTransform|System\\.Xml|org\\.xml\\.|sax\\.XMLReader|DocumentBuilderFactory|SAXParserFactory|DOM4J|XmlInputFactory|TransformerFactory|validation\\.Validator|validation\\.SchemaFactory|SAXTransformerFactory)", Pattern.CASE_INSENSITIVE);
  private static final Pattern CgiPattern = Pattern.compile("(/cgi-bin/|/cgi-sys/|/cgi-mod/|[a-zA-Z0-9]*\\.cgi)", Pattern.CASE_INSENSITIVE);
  private static final Pattern CmdPattern = Pattern.compile("(exec|shell|run|cmd|daemon|ping|command|func|^arg$|process|function|^func$|payload)", Pattern.CASE_INSENSITIVE);
  private static final Pattern SerialPattern = Pattern.compile("(serialize\\(\\),marshal\\.load|marshal\\.dump|unpickler|cpickle|ObjectInputStream\\.readUnshared|XStream\\.fromXML|XMLDecoder|ObjectInputStream\\.readObject|ObjectInputStream\\.defaultReadObject|LocateRegistry\\.createRegistry|Serialization\\.XmlSerializer|Serialization\\.DataContractSerializer|Serialization\\.NetDataContractSerializer|Serialization\\.JavaScriptSerializer|Serialization\\.Json\\.DataContractJsonSerializer|System\\.Resource\\.ResourceReader|Microsoft\\.Web\\.Design\\.Remote\\.ProxyObject|Newtonsoft\\.Json\\.JsonSerializationException|ServiceStack\\.Text|Binary\\.BinaryFormatter|Soap\\.SoapFormatter|UI\\.ObjectStateFormatter|Serialization\\.NetDataContractSerializer|UI\\.LosFormatter|Workflow\\.ComponentModel\\.Activity|SoapServerFormatterSinkProvider|SoapClientFormatterSinkProvider|BinaryServerFormatterSinkProvider|BinaryClientFormatterSinkProvider|SoapClientFormatterSink|SoapServerFormatterSink|BinaryClientFormatterSink|BinaryServerFormatterSink)", Pattern.CASE_INSENSITIVE);
  private static final Pattern SuspiciousPattern = Pattern.compile("(cfg|^conf$|config|dbg|debug|clone|enable|toggle|disable|load|test)", Pattern.CASE_INSENSITIVE);
  private static final Pattern SerialHeaderPattern = Pattern.compile("(x-java-serialized-object)");
  private static final Pattern FileHandlingPattern = Pattern.compile("(^doc$|^go$|goto|window|include|^inc$|prefix|locate|layout|document|callback|^dir$|directory|^dest$|destination|^feed$|html|domain|host|navigation|next|view|site|page|^pdf$|style|^img$|preview|^show$|activity|content|template|folder|^redir$|redirect|url|return|^file$|^image$|imagename|open|filename|^lang$|language|^home$|^homedir$)", Pattern.CASE_INSENSITIVE);
  private static final Pattern IdorHandlingPattern = Pattern.compile("(edit|profile|report|modify|[a-zA-Z0-9]id|^id$|group|user|order|number|^num$|account|key)", Pattern.CASE_INSENSITIVE);
  private static final Pattern SecretsPattern = Pattern.compile("(azure_storage_account|AZURE_STORAGE_ACCOUNT|azure_storage_access_key|AZURE_STORAGE_ACCESS_KEY|S3_KEY|S3_SECRET|AWS_ACCESS_KEY_ID|AWS_SECRET_ACCESS_KEY|AccessKeyId|SecretAccessKey|aws_access_key_id|aws_secret_access_key|aws_session_token|s3_key|s3_secret|accesskeyid|secretaccesskey|BEGIN RSA PRIVATE KEY|BEGIN DSA PRIVATE KEY|BEGIN EC PRIVATE KEY|BEGIN PGP PRIVATE KEY BLOCK|ya29\\.[0-9A-Za-z\\-_]+|A3T[A-Z0-9]|AKIA[0-9A-Z]{16}|ASIA[0-9A-Z]{16}|AGPA[A-Z0-9]{16}|AIDA[A-Z0-9]{16}|AROA[A-Z0-9]{16}|AIPA[A-Z0-9]{16}|ANPA[A-Z0-9]{16}|ANVA[A-Z0-9]{16}|amzn\\\\.mws\\\\.[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|EAACEdEose0cBA[0-9A-Za-z]+|key-[0-9a-zA-Z]{32}|SK[0-9a-fA-F]{32}|AC[a-zA-Z0-9_\\-]{32}|AP[a-zA-Z0-9_\\-]{32}|access_token\\$production\\$[0-9a-z]{16}\\$[0-9a-f]{32}|sq0csp-[ 0-9A-Za-z\\-_]{43}|sqOatp-[0-9A-Za-z\\-_]{22}|sk_live_[0-9a-zA-Z]{24}|rk_live_[0-9a-zA-Z]{24}|[a-zA-Z0-9_-]*:[a-zA-Z0-9_\\-]+@github\\.com*)");
  private static final Pattern S3BucketPattern = Pattern.compile("((?:\\w+://)?(?:([\\w.-]+)\\.s3[\\w.-]*\\.amazonaws\\.com|s3(?:[\\w.-]*\\.amazonaws\\.com(?:(?::\\d+)?\\\\?/)*|://)([\\w.-]+))(?:(?::\\d+)?\\\\?/)?(?:.*?\\?.*Expires=(\\d+))?)", Pattern.CASE_INSENSITIVE);
  private static final Pattern GoogleBucketPattern = Pattern.compile("((?:\\w+://)?(?:([\\w.-]+)\\.storage[\\w-]*\\.googleapis\\.com|(?:(?:console\\.cloud\\.google\\.com/storage/browser/|storage[\\w-]*\\.googleapis\\.com)(?:(?::\\d+)?\\\\?/)*|gs://)([\\w.-]+))(?:(?::\\d+)?\\\\?/([^\\s?#]*))?(?:.*\\?.*Expires=(\\d+))?)", Pattern.CASE_INSENSITIVE);
  private static final Pattern AzureBucketPattern = Pattern.compile("(([\\w.-]+\\.blob\\.core\\.windows\\.net(?::\\d+)?\\\\?/[\\w.-]+)(?:.*?\\?.*se=([\\w%-]+))?)", Pattern.CASE_INSENSITIVE);
  private static final Pattern FileValuePattern = Pattern.compile("(\\.com$|\\.net$|\\.org$|\\.io$|\\.xml$|\\.doc$|\\.docx$|\\.xls$|\\.xlsx$|\\.ppt$|\\.pptx$|\\.pdf$|\\.html$|\\.htm$|\\.js$|\\.json$|^http\\://|^https\\://|^ftp\\://|^file\\://|^php\\://|^jar\\://|^www\\.|^www1\\.|^www2\\.|^www3\\.|^ww1\\.|^ww2\\.|^ww3\\.)", Pattern.CASE_INSENSITIVE);
  private static final Pattern GcpFirebasePattern = Pattern.compile("([\\w.-]+\\.firebaseio\\.com/)", Pattern.CASE_INSENSITIVE );
  private static final Pattern AzureTablePattern = Pattern.compile("(([\\w.-]+\\.table\\.core\\.windows\\.net(?::\\d+)?\\\\?/[\\w.-]+)(?:.*?\\?.*se=([\\w%-]+))?)", Pattern.CASE_INSENSITIVE);
  private static final Pattern AzureQueuePattern = Pattern.compile("(([\\w.-]+\\.queue\\.core\\.windows\\.net(?::\\d+)?\\\\?/[\\w.-]+)(?:.*?\\?.*se=([\\w%-]+))?)", Pattern.CASE_INSENSITIVE);
  private static final Pattern AzureFilePattern = Pattern.compile("(([\\w.-]+\\.file\\.core\\.windows\\.net(?::\\d+)?\\\\?/[\\w.-]+)(?:.*?\\?.*se=([\\w%-]+))?)", Pattern.CASE_INSENSITIVE);
  private static final Pattern AzureCosmosPattern = Pattern.compile("(([\\w.-]+\\.documents\\.azure\\.com(?::\\d+)?\\\\?/[\\w.-]+)(?:.*?\\?.*se=([\\w%-]+))?)", Pattern.CASE_INSENSITIVE);
  private static final String aspMachineKeysHost = "raw.githubusercontent.com";
  private static final String aspMachineKeysProto = "https";
  private static final Integer aspMachineKeysPort = 443;
  private static final String aspMachineKeysUrl = "/NotSoSecure/Blacklist3r/master/MachineKey/AspDotNetWrapper/AspDotNetWrapper/Resource/MachineKeys.txt";
  private static final Pattern CloudFrontPattern = Pattern.compile("([\\w.-]+\\.cloudfront\\.net/)", Pattern.CASE_INSENSITIVE );
  private static final Pattern SubdomainTakeoverPattern = Pattern.compile("(NoSuchBucket|The specified bucket does not exist|herokucdn\\\\.com\\\\/error-pages\\\\/no-such-app\\\\.html|There isn't a GitHub Pages site here\\\\.|Do you want to register <em>[\\\\w.-]*\\\\.wordpress\\\\.com<\\\\/em>\\\\?|Sorry, this shop is currently unavailable|Repository not found|Whatever you were looking for doesn't currently exist at this address)", Pattern.CASE_INSENSITIVE);
  private static boolean isMachineKeysUrl = false;
  private static List<String> aspValidationKey = new ArrayList<String>();
  private PrintWriter printOut;

  // Basic extension setup
  @Override
  public void registerExtenderCallbacks(IBurpExtenderCallbacks callbacks) {
    extCallbacks = callbacks;
    extHelpers = extCallbacks.getHelpers();
    extCallbacks.setExtensionName("Indicators of Vulnerability");
    printOut = new PrintWriter(extCallbacks.getStdout(), true);
    
    // Attempt to get the pre-published ASP machine keys from Blacklist3r
    try {
      IHttpService httpService = extHelpers.buildHttpService(aspMachineKeysHost, aspMachineKeysPort, aspMachineKeysProto);
      List<String> headers = Arrays.asList("GET " + aspMachineKeysUrl + " HTTP/1.1", "Host: " + aspMachineKeysHost);
      byte[] request = extHelpers.buildHttpMessage(headers, new byte[0]);
      IHttpRequestResponse pubAspMachineKeysReq = extCallbacks.makeHttpRequest(httpService, request);
      String resp = new String(pubAspMachineKeysReq.getResponse());
      String respBody = resp.substring(extHelpers.analyzeResponse(pubAspMachineKeysReq.getResponse()).getBodyOffset());
      Reader pubAspMachineKeysResp = new StringReader(respBody);
      BufferedReader in = new BufferedReader(pubAspMachineKeysResp);

      // Read the contents of the URL
      String urlLine;
      //int a = 0;
      while ((urlLine = in.readLine()) != null) {
        aspValidationKey.add(urlLine.split(",")[0]);
      }

      in.close();

      isMachineKeysUrl = true;
    } catch (Exception ignore) { }
    
    // If we couldn't get the URL, read from disk
    if (!isMachineKeysUrl) {
      File extFile = new File(extCallbacks.getExtensionFilename());

      // Attempt to read included file
      try {
        BufferedReader br = new BufferedReader(new FileReader(extFile.getParent() + "/MachineKeys.txt"));  
        String fileLine;
        
        // Read the contents of the file
        while ((fileLine = br.readLine()) != null) {  
          aspValidationKey.add(fileLine.split(",")[0]);
        }
        br.close();

        isMachineKeysUrl = true;
      } catch (Exception ignore) { }
    }
    
    extCallbacks.registerHttpListener(this);
    extCallbacks.registerScannerCheck(this);
    printHeader();    
  }
  
  // Print to extension output tab
  public void printHeader() {
    printOut.println("Indicators of Vulnerability: " + burpIVVersion + "\n====================\nMonitor requests and responses for common indicators of SQLi, CMDi, XXE, Serialization, SSRF, SSTI, LFI, RFI, and Directory Traversal issues.\n\n"
      + "josh.berry@codewatch.org\n\n");
  }
  
  // Perform a passive check for cloud buckets
  @Override
  public List<IScanIssue> doPassiveScan(IHttpRequestResponse messageInfo) {
    // Only process requests if the URL is in scope
    if (extCallbacks.isInScope(extHelpers.analyzeRequest(messageInfo).getUrl())) {
        
      // Setup default request variables for URL and body
      IRequestInfo requestInfo = extHelpers.analyzeRequest(messageInfo);
      String reqUrl = requestInfo.getUrl().toString();
      String resp = new String(messageInfo.getResponse());
      List<String> headers = requestInfo.getHeaders();
      String respBody = resp.substring(extHelpers.analyzeResponse(messageInfo.getResponse()).getBodyOffset());
      String reqRaw = new String(messageInfo.getRequest());
      String reqBody = reqRaw.substring(requestInfo.getBodyOffset());
      Matcher SerialRespMatch = SerialHeaderPattern.matcher(resp);
      Matcher CgiUrlMatch = CgiPattern.matcher(reqUrl);
      Matcher S3BucketUrlMatch = S3BucketPattern.matcher(reqUrl);
      Matcher S3BucketBodyMatch = S3BucketPattern.matcher(reqBody);
      Matcher GoogleBucketUrlMatch = GoogleBucketPattern.matcher(reqUrl);
      Matcher GoogleBucketBodyMatch = GoogleBucketPattern.matcher(reqBody);
      Matcher AzureBucketUrlMatch = AzureBucketPattern.matcher(reqUrl);
      Matcher AzureBucketBodyMatch = AzureBucketPattern.matcher(reqBody);
      Matcher AzureTableMatch = AzureTablePattern.matcher(reqBody);
      Matcher AzureQueueMatch = AzureQueuePattern.matcher(reqBody);
      Matcher AzureFileMatch = AzureFilePattern.matcher(reqBody);
      Matcher AzureCosmosMatch = AzureCosmosPattern.matcher(reqBody);
      Matcher GcpFirebaseMatch = GcpFirebasePattern.matcher(reqBody);
      Matcher CloudFrontMatch = CloudFrontPattern.matcher(reqBody);
      Matcher S3BucketRespMatch = S3BucketPattern.matcher(respBody);
      Matcher GoogleBucketRespMatch = GoogleBucketPattern.matcher(respBody);
      Matcher AzureBucketRespMatch = AzureBucketPattern.matcher(respBody);
      Matcher AzureTableRespMatch = AzureTablePattern.matcher(respBody);
      Matcher AzureQueueRespMatch = AzureQueuePattern.matcher(respBody);
      Matcher AzureFileRespMatch = AzureFilePattern.matcher(respBody);
      Matcher AzureCosmosRespMatch = AzureCosmosPattern.matcher(respBody);
      Matcher GcpFirebaseRespMatch = GcpFirebasePattern.matcher(respBody);
      Matcher CloudFrontRespMatch = CloudFrontPattern.matcher(respBody);
      
      // Check headers for indicators
      for (int i = 0; i < headers.size(); i++) {
        
        // Match against serialized object
        Matcher SerialHeaderMatch = SerialHeaderPattern.matcher(headers.get(i));
        
        if (SerialHeaderMatch.find()) {
          List<int[]> SerialHeaderMatches = getMatches(messageInfo.getRequest(), SerialHeaderMatch.group(0).getBytes());
          reportIssue(messageInfo, SerialHeaderMatches, null, "[IoV] Serialization Indicator of Vulnerability", "The request contained the following header: " + SerialHeaderMatch.group(0), "Information", "Tentative");
        }
        
        // If we got the pre-published keys, check for them
        if (isMachineKeysUrl) {
          int aspValidationKeySize = aspValidationKey.size();
          
          // Loop through the list of keys of a match
          for (int j = 0; j < aspValidationKeySize; j++ ) {
            Pattern aspValidationPattern = Pattern.compile(aspValidationKey.get(j), Pattern.CASE_INSENSITIVE);
            Matcher aspValidationMatch = aspValidationPattern.matcher(headers.get(i));
            
            // Create an issue if there was a match
            if (aspValidationMatch.find()) {
              List<int[]> aspValidationMatches = getMatches(messageInfo.getRequest(), aspValidationMatch.group(0).getBytes());
              reportIssue(messageInfo, aspValidationMatches, null, "[IoV] Pre-Published ASP.NET Validation Keys", "The request headers contained the following pre-published ASP.NET validation key: " + aspValidationMatch.group(0) + "<BR><BR>See the following for more details: https://www.notsosecure.com/project-blacklist3r/.", "Medium", "Firm");
            }
          }
        }
      }
      
      // Check responses for cloud and other issues
     
      // Create an issue if we match any of the potential sources of attack for
      // CMDi a-la ShellShock. More to be added later. These are areas to focus these attacks,
      // not confirmed vulnerabilities.
      if (CgiUrlMatch.find()) {
        List<int[]> CgiUrlMatches = getMatches(messageInfo.getRequest(), CgiUrlMatch.group(0).getBytes());
        reportIssue(messageInfo, CgiUrlMatches, null, "[IoV] Target for ShellShock CMDi", "The URL contained the following path/file: " + CgiUrlMatch.group(0), "Information", "Tentative");
      }
        
      // Create an issue noting an AWS S3 Bucket was identified in the URL
      if (S3BucketUrlMatch.find()) {
        List<int[]> S3BucketUrlMatches = getMatches(messageInfo.getRequest(), S3BucketUrlMatch.group(0).getBytes());
        reportIssue(messageInfo, S3BucketUrlMatches, null, "[IoV] AWS S3 Bucket Identified", "The URL contained the following bucket: " + S3BucketUrlMatch.group(0), "Information", "Firm");
      }
        
      // Create an issue noting a Google Bucket was identified in the URL
      if (GoogleBucketUrlMatch.find()) {
        List<int[]> GoogleBucketUrlMatches = getMatches(messageInfo.getRequest(), GoogleBucketUrlMatch.group(0).getBytes());
        reportIssue(messageInfo, GoogleBucketUrlMatches, null, "[IoV] Google Storage Bucket Identified", "The URL contained the following bucket: " + GoogleBucketUrlMatch.group(0), "Information", "Firm");
      }

      // Create an issue noting an Azure Bucket was identified in the URL
      if (AzureBucketUrlMatch.find()) {
        List<int[]> AzureBucketUrlMatches = getMatches(messageInfo.getRequest(), AzureBucketUrlMatch.group(0).getBytes());
        reportIssue(messageInfo, AzureBucketUrlMatches, null, "[IoV] Azure Storage Container Identified", "The URL contained the following bucket: " + AzureBucketUrlMatch.group(0), "Information", "Firm");
      }
        
      // Create an issue noting an AWS S3 Bucket was identified in the request
      if (S3BucketBodyMatch.find()) {
        List<int[]> S3BucketBodyMatches = getMatches(messageInfo.getRequest(), S3BucketBodyMatch.group(0).getBytes());
        reportIssue(messageInfo, S3BucketBodyMatches, null, "[IoV] AWS S3 Bucket Identified", "The request body contained the following bucket: " + S3BucketBodyMatch.group(0), "Information", "Firm");
      }
        
      // Create an issue noting a Google Bucket was identified in the request
      if (GoogleBucketBodyMatch.find()) {
        List<int[]> GoogleBucketBodyMatches = getMatches(messageInfo.getRequest(), GoogleBucketBodyMatch.group(0).getBytes());
        reportIssue(messageInfo, GoogleBucketBodyMatches, null, "[IoV] Google Storage Bucket Identified", "The request body contained the following bucket: " + GoogleBucketBodyMatch.group(0), "Information", "Firm");
      }

      // Create an issue noting an Azure Bucket was identified in the request
      if (AzureBucketBodyMatch.find()) {
        List<int[]> AzureBucketBodyMatches = getMatches(messageInfo.getRequest(), AzureBucketBodyMatch.group(0).getBytes());
        reportIssue(messageInfo, AzureBucketBodyMatches, null, "[IoV] Azure Storage Container Identified", "The request body contained the following bucket: " + AzureBucketBodyMatch.group(0), "Information", "Firm");
      }
        
      // Create an issue noting an Azure Table was identified in the request
      if (AzureTableMatch.find()) {
        List<int[]> AzureTableMatches = getMatches(messageInfo.getRequest(), AzureTableMatch.group(0).getBytes());
        reportIssue(messageInfo, AzureTableMatches, null, "[IoV] Azure Storage Container Identified - Table", "The request body contained the following table: " + AzureTableMatch.group(0), "Information", "Firm");
      }
        
      // Create an issue noting an Azure Queue was identified in the request
      if (AzureQueueMatch.find()) {
        List<int[]> AzureQueueMatches = getMatches(messageInfo.getRequest(), AzureQueueMatch.group(0).getBytes());
        reportIssue(messageInfo, AzureQueueMatches, null, "[IoV] Azure Storage Container Identified - Queue", "The request body contained the following queue: " + AzureQueueMatch.group(0), "Information", "Firm");
      }
        
      // Create an issue noting an Azure Share was identified in the request
      if (AzureFileMatch.find()) {
        List<int[]> AzureFileMatches = getMatches(messageInfo.getRequest(), AzureFileMatch.group(0).getBytes());
        reportIssue(messageInfo, AzureFileMatches, null, "[IoV] Azure Storage Container Identified - Share", "The request body contained the following share: " + AzureFileMatch.group(0), "Information", "Firm");
      }
        
      // Create an issue noting an Azure Cosmos DB was identified in the request
      if (AzureCosmosMatch.find()) {
        List<int[]> AzureCosmosMatches = getMatches(messageInfo.getRequest(), AzureCosmosMatch.group(0).getBytes());
        reportIssue(messageInfo, AzureCosmosMatches, null, "[IoV] Azure Cosmos Database Identified", "The request body contained the following Cosmos DB: " + AzureCosmosMatch.group(0), "Information", "Firm");
      }
        
      // Create an issue noting a Firebase.io database was identified in the request
      if (GcpFirebaseMatch.find()) {
        List<int[]> GcpFirebaseMatches = getMatches(messageInfo.getRequest(), GcpFirebaseMatch.group(0).getBytes());
        reportIssue(messageInfo, GcpFirebaseMatches, null, "[IoV] Firebase Database Identified", "The request body contained the following Firebase DB: " + GcpFirebaseMatch.group(0), "Information", "Firm");
      }
        
      // Create an issue noting a Cloudfront resource was identified in the response
      if (CloudFrontMatch.find()) {
        List<int[]> CloudFrontMatches = getMatches(messageInfo.getRequest(), CloudFrontMatch.group(0).getBytes());
        reportIssue(messageInfo, CloudFrontMatches, null, "[IoV] Cloudfront Resource Identified", "The request body contained the following Cloudfront URL: " + CloudFrontMatch.group(0), "Information", "Firm");
      }
      
      // Create an issue noting an AWS S3 Bucket was identified in the response
      if (S3BucketRespMatch.find()) {
        List<int[]> S3BucketRespMatches = getMatches(messageInfo.getResponse(), S3BucketRespMatch.group(0).getBytes());
        reportIssue(messageInfo, null, S3BucketRespMatches, "[IoV] AWS S3 Bucket Identified", "The response body contained the following bucket: " + S3BucketRespMatch.group(0), "Information", "Firm");
      }
        
      // Create an issue noting a Google Bucket was identified in the response
      if (GoogleBucketRespMatch.find()) {
        List<int[]> GoogleBucketRespMatches = getMatches(messageInfo.getResponse(), GoogleBucketRespMatch.group(0).getBytes());
        reportIssue(messageInfo, null, GoogleBucketRespMatches, "[IoV] Google Storage Bucket Identified", "The response body contained the following bucket: " + GoogleBucketRespMatch.group(0), "Information", "Firm");
      }

      // Create an issue noting an Azure Bucket was identified in the response
      if (AzureBucketRespMatch.find()) {
        List<int[]> AzureBucketRespMatches = getMatches(messageInfo.getResponse(), AzureBucketRespMatch.group(0).getBytes());
        reportIssue(messageInfo, null, AzureBucketRespMatches, "[IoV] Azure Storage Container Identified", "The response body contained the following bucket: " + AzureBucketRespMatch.group(0), "Information", "Firm");
      }
        
      // Create an issue noting an Azure Table was identified in the response
      if (AzureTableRespMatch.find()) {
        List<int[]> AzureTableRespMatches = getMatches(messageInfo.getResponse(), AzureTableRespMatch.group(0).getBytes());
        reportIssue(messageInfo, null, AzureTableRespMatches, "[IoV] Azure Storage Container Identified - Table", "The response body contained the following table: " + AzureTableRespMatch.group(0), "Information", "Firm");
      }
        
      // Create an issue noting an Azure Queue was identified in the response
      if (AzureQueueRespMatch.find()) {
        List<int[]> AzureQueueRespMatches = getMatches(messageInfo.getResponse(), AzureQueueRespMatch.group(0).getBytes());
        reportIssue(messageInfo, null, AzureQueueRespMatches, "[IoV] Azure Storage Container Identified - Queue", "The response body contained the following queue: " + AzureQueueRespMatch.group(0), "Information", "Firm");
      }
        
      // Create an issue noting an Azure Share was identified in the response
      if (AzureFileRespMatch.find()) {
        List<int[]> AzureFileRespMatches = getMatches(messageInfo.getResponse(), AzureFileRespMatch.group(0).getBytes());
        reportIssue(messageInfo, null, AzureFileRespMatches, "[IoV] Azure Storage Container Identified - Share", "The response body contained the following share: " + AzureFileRespMatch.group(0), "Information", "Firm");
      }
        
      // Create an issue noting an Azure Cosmos DB was identified in the response
      if (AzureCosmosRespMatch.find()) {
        List<int[]> AzureCosmosRespMatches = getMatches(messageInfo.getResponse(), AzureCosmosRespMatch.group(0).getBytes());
        reportIssue(messageInfo, null, AzureCosmosRespMatches, "[IoV] Azure Cosmos Database Identified", "The response body contained the following Cosmos DB: " + AzureCosmosRespMatch.group(0), "Information", "Firm");
      }
        
      // Create an issue noting a Firebase.io database was identified in the response
      if (GcpFirebaseRespMatch.find()) {
        List<int[]> GcpFirebaseRespMatches = getMatches(messageInfo.getResponse(), GcpFirebaseRespMatch.group(0).getBytes());
        reportIssue(messageInfo, null, GcpFirebaseRespMatches, "[IoV] Firebase Database Identified", "The response body contained the following Firebase DB: " + GcpFirebaseRespMatch.group(0), "Information", "Firm");
      }
        
      // Create an issue noting a Cloudfront resource was identified in the response
      if (CloudFrontRespMatch.find()) {
        List<int[]> CloudFrontRespMatches = getMatches(messageInfo.getResponse(), CloudFrontRespMatch.group(0).getBytes());
        reportIssue(messageInfo, null, CloudFrontRespMatches, "[IoV] Cloudfront Resource Identified", "The response body contained the following Cloudfront URL: " + CloudFrontRespMatch.group(0), "Information", "Firm");
      }
      
      // If we got the pre-published keys, check for them
      if (isMachineKeysUrl) {
        int aspValidationKeySize = aspValidationKey.size();
          
        // Loop through the list of keys of a match
        for (int k = 0; k < aspValidationKeySize; k++ ) {
          Pattern aspValidationPattern = Pattern.compile(aspValidationKey.get(k), Pattern.CASE_INSENSITIVE);
          Matcher aspValidationMatch = aspValidationPattern.matcher(resp);
          Matcher aspReqValidationMatch = aspValidationPattern.matcher(reqBody);
            
          // Create an issue if there was a match
          if (aspValidationMatch.find()) {
            List<int[]> aspValidationMatches = getMatches(messageInfo.getResponse(), aspValidationMatch.group(0).getBytes());
            reportIssue(messageInfo, null, aspValidationMatches, "[IoV] Pre-Published ASP.NET Validation Keys", "The response contained the following pre-published ASP.NET validation key: " + aspValidationMatch.group(0) + "<BR><BR>See the following for more details: https://www.notsosecure.com/project-blacklist3r/.", "Medium", "Firm");
          }
          
          // Create an issue if there was a match
          if (aspReqValidationMatch.find()) {
            List<int[]> aspReqValidationMatches = getMatches(messageInfo.getRequest(), aspReqValidationMatch.group(0).getBytes());
            reportIssue(messageInfo, aspReqValidationMatches, null, "[IoV] Pre-Published ASP.NET Validation Keys", "The request body contained the following pre-published ASP.NET validation key: " + aspReqValidationMatch.group(0) + "<BR><BR>See the following for more details: https://www.notsosecure.com/project-blacklist3r/.", "Medium", "Firm");
          }
        }
      }
      
      // Create an issue if we match any of the indicators for a serialized object
      if (SerialRespMatch.find()) {
        List<int[]> SerialHeaderMatches = getMatches(messageInfo.getResponse(), SerialRespMatch.group(0).getBytes());
        reportIssue(messageInfo, null, SerialHeaderMatches, "[IoV] Serialization Indicator of Vulnerability", "The response contained the following text: " + SerialRespMatch.group(0), "Low", "Tentative");
      }
      
      // Check Parameters for potential targets of attack
      for (IParameter parameter : requestInfo.getParameters()) {
        Matcher FileParamMatch = FileHandlingPattern.matcher(parameter.getName());
        Matcher FileParamValueMatch = FileValuePattern.matcher(parameter.getValue());
        Matcher CmdParamMatch = CmdPattern.matcher(parameter.getName());
        Matcher CmdParamValueMatch = CmdPattern.matcher(parameter.getValue());
        Matcher SuspiciousParamMatchName = SuspiciousPattern.matcher(parameter.getName());
        Matcher SuspiciousParamMatchValue = SuspiciousPattern.matcher(parameter.getValue());
        Matcher IdorParamMatch = IdorHandlingPattern.matcher(parameter.getName());
        Matcher SqlParamMatch = SqlParamPattern.matcher(parameter.getName());
      
        // Create an issue if we match any of the potential sources of attack for
        // SSTI/ SSRF / LFI / RFI / Directory Traversal / URL injection. These are areas to focus
        // these attacks, not confirmed vulnerabilities.
        if (FileParamMatch.find()) {
          List<int[]> FileParamMatches = getMatches(messageInfo.getRequest(), FileParamMatch.group(0).getBytes());
          reportIssue(messageInfo, FileParamMatches, null, "[IoV] Target for SSRF/SSTI/LFI/RFI/URLi/DirTraversal", "The request contained the following potential target parameter name: " + FileParamMatch.group(0), "Information", "Tentative");
        }
        
        // Check for parameter values that might be vulnerable to SSRF / URL redirection / etc
        if (FileParamValueMatch.find()) {
          List<int[]> FileParamValueMatches = getMatches(messageInfo.getRequest(), FileParamValueMatch.group(0).getBytes());
          reportIssue(messageInfo, FileParamValueMatches, null, "[IoV] Target for SSRF/SSTI/LFI/RFI/URLi/DirTraversal", "The request contained the following potential target parameter value: " + FileParamValueMatch.group(0), "Information", "Tentative");
        }
        
        // Check for parameters indicative of being vulnerable to CMDi
        if (CmdParamMatch.find()) {
          List<int[]> CmdParamMatches = getMatches(messageInfo.getRequest(), CmdParamMatch.group(0).getBytes());
          reportIssue(messageInfo, CmdParamMatches, null, "[IoV] Target for CMDi", "The request contained the following potential target parameter name: " + CmdParamMatch.group(0), "Information", "Tentative");
        }
        
        // Check for parameters indicative of being vulnerable to CMDi
        if (CmdParamValueMatch.find()) {
          List<int[]> CmdParamMatches = getMatches(messageInfo.getRequest(), CmdParamValueMatch.group(0).getBytes());
          reportIssue(messageInfo, CmdParamMatches, null, "[IoV] Target for CMDi", "The request contained the following potential target parameter value: " + CmdParamValueMatch.group(0), "Information", "Tentative");
        }
        
        // Check for parameters that are suspicious
        if (SuspiciousParamMatchName.find()) {
          List<int[]> SuspiciousParamMatches = getMatches(messageInfo.getRequest(), SuspiciousParamMatchName.group(0).getBytes());
          reportIssue(messageInfo, SuspiciousParamMatches, null, "[IoV] Suspicious Parameters to Target", "The request contained the following potential target parameter name: " + SuspiciousParamMatchName.group(0), "Information", "Tentative");
        }
        
        if (SuspiciousParamMatchValue.find()) {
          List<int[]> SuspiciousParamMatches = getMatches(messageInfo.getRequest(), SuspiciousParamMatchValue.group(0).getBytes());
          reportIssue(messageInfo, SuspiciousParamMatches, null, "[IoV] Suspicious Parameters to Target", "The request contained the following potential target parameter value: " + SuspiciousParamMatchValue.group(0), "Information", "Tentative");
        }
        
        // Check for parameters indicative of being vulnerable to IDOR
        if (IdorParamMatch.find()) {
          if (parameter.getValue().matches("^[0-9].*")) {
            List<int[]> IdorParamMatches = getMatches(messageInfo.getRequest(), IdorParamMatch.group(0).getBytes());
            reportIssue(messageInfo, IdorParamMatches, null, "[IoV] Target for IDOR", "The request contained the following potential target parameter: " + IdorParamMatch.group(0), "Information", "Tentative");
          }
        }
        
        // Check for parameters indicative of being vulnerable to IDOR
        if (SqlParamMatch.find()) {
          List<int[]> SqlParamMatches = getMatches(messageInfo.getRequest(), SqlParamMatch.group(0).getBytes());
          reportIssue(messageInfo, SqlParamMatches, null, "[IoV] Target for SQLi", "The request contained the following potential target parameter: " + SqlParamMatch.group(0), "Information", "Tentative");
        }
      }
    }
      
    return null;
  }
  
  // No active scanning for this but still must define it
  @Override
  public List<IScanIssue> doActiveScan(IHttpRequestResponse baseRequestResponse, IScannerInsertionPoint insertionPoint) {
    return null;
  }
  
  @Override
  public int consolidateDuplicateIssues(IScanIssue existingIssue, IScanIssue newIssue) {
    // This method is called when multiple issues are reported for the same URL 
    // path by the same extension-provided check. The value we return from this 
    // method determines how/whether Burp consolidates the multiple issues
    // to prevent duplication
    //
    // Since the issue name is sufficient to identify our issues as different,
    // if both issues have the same name, only report the existing issue
    // otherwise report both issues
    if (existingIssue.getIssueName().equals(newIssue.getIssueName()))
      return -1;
    else return 0;
  }
  
  // Process requests and responses and look for specified content
  @Override
  public void processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo) {
    // Only process requests if the URL is in scope
    if (extCallbacks.isInScope(extHelpers.analyzeRequest(messageInfo).getUrl())) {
    
      // Process checks in the response
      if (!messageIsRequest) {
        // Setup default response body variable
        String respRaw = new String(messageInfo.getResponse());
        String respBody = respRaw.substring(extHelpers.analyzeResponse(messageInfo.getResponse()).getBodyOffset());
      
        // Create patter matchers for each type
        Matcher XxeMatch = XxePattern.matcher(respBody);
        Matcher SqlMatch = SqlPattern.matcher(respBody);
        Matcher SerialMatch = SerialPattern.matcher(respBody);
        Matcher SecretsMatch = SecretsPattern.matcher(respBody);
        Matcher SubdomainTakeoverMatch = SubdomainTakeoverPattern.matcher(respBody);
      
        // Create an issue if we match any of the indicators for XXE vulnerabilities
        if (XxeMatch.find()) {
          List<int[]> XxeMatches = getMatches(messageInfo.getResponse(), XxeMatch.group(0).getBytes());
          reportIssue(messageInfo, null, XxeMatches, "[IoV] XXE Indicator of Vulnerability", "The response contained the following text: " + XxeMatch.group(0), "Low", "Tentative");
        }
      
        // Create an issue if we match any of the indicators for SQLi vulnerabilities
        if (SqlMatch.find()) {
          List<int[]> SqlMatches = getMatches(messageInfo.getResponse(), SqlMatch.group(0).getBytes());
          reportIssue(messageInfo, null, SqlMatches, "[IoV] SQLi Indicator of Vulnerability", "The response contained the following text: " + SqlMatch.group(0), "Low", "Tentative");
        }
      
        // Create an issue if we match any of the indicators for Deserialization vulnerabilities
        if (SerialMatch.find()) {
          List<int[]> SerialMatches = getMatches(messageInfo.getResponse(), SerialMatch.group(0).getBytes());
          reportIssue(messageInfo, null, SerialMatches, "[IoV] Serialization Indicator of Vulnerability", "The response contained the following text: " + SerialMatch.group(0), "Low", "Tentative");
        }
      
        // Create an issue if we match any potential secrets
        if (SecretsMatch.find()) {
          List<int[]> SecretsMatches = getMatches(messageInfo.getResponse(), SecretsMatch.group(0).getBytes());
          reportIssue(messageInfo, null, SecretsMatches, "[IoV] Leaked Secrets Indicator of Vulnerability", "The response contained the following text: " + SecretsMatch.group(0), "Medium", "Tentative");
        }
        
        // Create an issue noting the response indicates the potential for subdomain takeover
        if (SubdomainTakeoverMatch.find()) {
          List<int[]> SubdomainTakeoverMatches = getMatches(messageInfo.getResponse(), SubdomainTakeoverMatch.group(0).getBytes());
          reportIssue(messageInfo, null, SubdomainTakeoverMatches, "[IoV] Subdomain Takeover Potential", "The response body contained a string that indicates vulnerability to subdomain takeovers: " + SubdomainTakeoverMatch.group(0) + "<BR>See also: https://github.com/EdOverflow/can-i-take-over-xyz", "High", "Firm");
        }     
      }
    }
  }
  
  // helper method to search a response for occurrences of a literal match string
  // and return a list of start/end offsets
  private List<int[]> getMatches(byte[] response, byte[] match) {
    List<int[]> matches = new ArrayList<int[]>();

    int start = 0;
    while (start < response.length) {
      start = extHelpers.indexOf(response, match, true, start, response.length);
      if (start == -1)
        break;
      matches.add(new int[] { start, start + match.length });
      start += match.length;
    }

    return matches;
  }
  
  // Create issues from the reported findings
  private IScanIssue reportIssue(IHttpRequestResponse baseRequestResponse, List<int[]>reqMatches, List<int[]>respMatches, String IssueName, String IssueMatch, String Severity, String Confidence) {
      IScanIssue issue = new CustomScanIssue(
          baseRequestResponse.getHttpService(),
          extHelpers.analyzeRequest(baseRequestResponse).getUrl(), 
          new IHttpRequestResponse[] { extCallbacks.applyMarkers(baseRequestResponse, reqMatches, respMatches) }, 
          IssueName,
          IssueMatch,
          Severity,
          Confidence
      );

      String issueUrl = extHelpers.analyzeRequest(baseRequestResponse).getUrl().getProtocol() + "://" + extHelpers.analyzeRequest(baseRequestResponse).getUrl().getHost() + extHelpers.analyzeRequest(baseRequestResponse).getUrl().getPath();
      IScanIssue issues[] = extCallbacks.getScanIssues(issueUrl);
      int ReportMatch = 0;

      if (issues.length >= 1) {
        for (int i=0; i<issues.length;i++) { 
          if (issues[i].getIssueName().equals(IssueName)) {
            ReportMatch = 1;
          }
        }
        
        if (ReportMatch == 0) {
          extCallbacks.addScanIssue(issue);
        }
      } else {
        extCallbacks.addScanIssue(issue);
      }

      return issue;
  }
}

class CustomScanIssue implements IScanIssue {
  private IHttpService httpService;
  private URL url;
  private IHttpRequestResponse[] httpMessages;
  private String name;
  private String detail;
  private String severity;
  private String confidence;

  public CustomScanIssue(IHttpService httpService, URL url, IHttpRequestResponse[] httpMessages, String name, String detail, String severity, String confidence) {
    this.httpService = httpService;
    this.url = url;
    this.httpMessages = httpMessages;
    this.name = name;
    this.detail = detail;
    this.severity = severity;
    this.confidence = confidence;
  }
    
  @Override
  public URL getUrl() {
    return url;
  }

  @Override
  public String getIssueName() {
    return name;
  }

  @Override
  public int getIssueType() {
    return 0;
  }

  @Override
  public String getSeverity() {
    return severity;
  }

  @Override
  public String getConfidence() {
    return confidence;
  }

  @Override
  public String getIssueBackground() {
    return null;
  }

  @Override
  public String getRemediationBackground() {
    return null;
  }

  @Override
  public String getIssueDetail() {
    return detail;
  }

  @Override
  public String getRemediationDetail() {
    return null;
  }

  @Override
  public IHttpRequestResponse[] getHttpMessages() {
    return httpMessages;
  }

  @Override
  public IHttpService getHttpService() {
    return httpService;
  }
}