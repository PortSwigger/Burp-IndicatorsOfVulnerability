/*
 * Name:           Burp Indicators of Vulnerability
 * Version:        0.1
 * Date:           1/9/2019
 * Author:         Josh Berry - josh.berry@codewatch.org
 * Github:         https://github.com/codewatchorg/Burp-IV
 * 
 * Description:    This plugin checks application responses and in some cases browser requests for indications of SQLi, XXE, and other vulnerabilities or attack points for these issues.
 * 
*/

package burp;

import java.util.List;
import java.util.ArrayList;
import java.io.PrintWriter;
import java.net.URL;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class BurpExtender implements IBurpExtender, IHttpListener {

  // Setup extension wide variables
  public IBurpExtenderCallbacks extCallbacks;
  public IExtensionHelpers extHelpers;
  private static final String burpIVVersion = "0.1";
  private static final Pattern SqlPattern = Pattern.compile("(SQL Server|MySQL|MariaDB|Postgres|Oracle|ORA\\-[0-9][0-9]|OLE DB Provider|JET Database|Type mismatch|error in your SQL|Invalid SQL|OLEDB Exception|ADODB|OLEDB Provider|OleDbException|ODBC)", Pattern.CASE_INSENSITIVE);
  private static final Pattern XxePattern = Pattern.compile("(XML Reader error|java\\.xml\\.|UnmarshalException|Marshaller|Xml\\.XmlDocument|Xml\\.XmlDictionaryReader|Xml\\.XmlNodeReader|Xml\\.XmlReader|Xml\\.XmlTextReader|Xml\\.Xpath\\.XpathNavigator|Xsl\\.XslCompiledTransform|System\\.Xml|org\\.xml\\.|sax\\.XMLReader|DocumentBuilderFactory|SAXParserFactory|DOM4J|XmlInputFactory|TransformerFactory|validation\\.Validator|validation\\.SchemaFactory|SAXTransformerFactory)", Pattern.CASE_INSENSITIVE);
  private static final Pattern CgiPattern = Pattern.compile("(/cgi-bin/|/cgi-sys/|/cgi-mod/|[a-zA-Z0-9]\\.cgi)", Pattern.CASE_INSENSITIVE);
  private static final Pattern SerialPattern = Pattern.compile("(serialize\\(\\),marshal\\.load|marshal\\.dump|unpickler|cpickle|ObjectInputStream\\.readUnshared|XStream\\.fromXML|XMLDecoder|ObjectInputStream\\.readObject|ObjectInputStream\\.defaultReadObject|LocateRegistry\\.createRegistry|Serialization\\.XmlSerializer|Serialization\\.DataContractSerializer|Serialization\\.NetDataContractSerializer|Serialization\\.JavaScriptSerializer|Serialization\\.Json\\.DataContractJsonSerializer|System\\.Resource\\.ResourceReader|Microsoft\\.Web\\.Design\\.Remote\\.ProxyObject|Newtonsoft\\.Json\\.JsonSerializationException|ServiceStack\\.Text|Binary\\.BinaryFormatter|Soap\\.SoapFormatter|UI\\.ObjectStateFormatter|Serialization\\.NetDataContractSerializer|UI\\.LosFormatter|Workflow\\.ComponentModel\\.Activity|SoapServerFormatterSinkProvider|SoapClientFormatterSinkProvider|BinaryServerFormatterSinkProvider|BinaryClientFormatterSinkProvider|SoapClientFormatterSink|SoapServerFormatterSink|BinaryClientFormatterSink|BinaryServerFormatterSink)", Pattern.CASE_INSENSITIVE);
  private static final Pattern FileHandlingPattern = Pattern.compile("(redir|redirect|url|path|return|file|image|open|filename)=", Pattern.CASE_INSENSITIVE);
  private PrintWriter printOut;

  // Basic extension setup
  @Override
  public void registerExtenderCallbacks(IBurpExtenderCallbacks callbacks) {
    extCallbacks = callbacks;
    extHelpers = extCallbacks.getHelpers();
    extCallbacks.setExtensionName("Indicators of Vulnerability");
    printOut = new PrintWriter(extCallbacks.getStdout(), true);
    extCallbacks.registerHttpListener(this);
    printHeader();    
  }
  
  // Print to extension output tab
  public void printHeader() {
    printOut.println("Indicators of Vulnerability: " + burpIVVersion + "\n====================\nMonitor requests and responses for common indicators of SQLi, CMDi, XXE, Serialization, SSRF, LFI, RFI, and Directory Traversal issues.\n\n"
      + "josh.berry@codewatch.org\n\n");
  }
  
  // Process requests and responses and look for specified content
  @Override
  public void processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo) {
    // Process checks in the request
    if (messageIsRequest) {
      // Setup default request variables for URL and body
      IRequestInfo requestInfo = extHelpers.analyzeRequest(messageInfo);
      String reqUrl = requestInfo.getUrl().toString();
      String reqRaw = new String(messageInfo.getRequest());
      String reqBody = reqRaw.substring(requestInfo.getBodyOffset());
      
      // Create patter matchers for each type
      Matcher FileUrlMatch = FileHandlingPattern.matcher(reqUrl);
      Matcher FileBodyMatch = FileHandlingPattern.matcher(reqBody);
      Matcher CgiUrlMatch = CgiPattern.matcher(reqUrl);
      
      // Create an issue if we match any of the potential sources of attack for
      // SSRF / LFI / RFI / Directory Traversal / URL injection. These are areas to focus
      // these attacks, not confirmed vulnerabilities.
      if (FileUrlMatch.find()) {
        List<int[]> FileUrlMatches = getMatches(messageInfo.getRequest(), FileUrlMatch.group(0).getBytes());
        if (FileUrlMatches.size() > 0) {
          reportIssue(messageInfo, FileUrlMatches, "[IoV] Target for SSRF/LFI/RFI/URLi/DirTraversal", "The URL contained the following potential target parameter: " + FileUrlMatch.group(0), "Information", "Tentative");
        }
      }
      
      if (FileBodyMatch.find()) {
        List<int[]> FileBodyMatches = getMatches(messageInfo.getRequest(), FileBodyMatch.group(0).getBytes());
        if (FileBodyMatches.size() > 0) {
          reportIssue(messageInfo, FileBodyMatches, "[IoV] Target for SSRF/LFI/RFI/URLi/DirTraversal", "The response contained the following potential target parameter: " + FileBodyMatch.group(0), "Information", "Tentative");
        }
      }
      
      // Create an issue if we match any of the potential sources of attack for
      // CMDi a-la ShellShock. More to be added later. These are areas to focus these attacks,
      // not confirmed vulnerabilities.
      if (CgiUrlMatch.find()) {
        List<int[]> CgiUrlMatches = getMatches(messageInfo.getRequest(), CgiUrlMatch.group(0).getBytes());
        if (CgiUrlMatches.size() > 0) {
          reportIssue(messageInfo, CgiUrlMatches, "[IoV] Target for ShellShock CMDi", "The URL contained the following path/file: " + CgiUrlMatch.group(0), "Information", "Tentative");
        }
      }
      
    // Process checks in the response
    } else {
      // Setup default response body variable
      String respRaw = new String(messageInfo.getResponse());
      String respBody = respRaw.substring(extHelpers.analyzeResponse(messageInfo.getResponse()).getBodyOffset());
      
      // Create patter matchers for each type
      Matcher XxeMatch = FileHandlingPattern.matcher(respBody);
      Matcher SqlMatch = SqlPattern.matcher(respBody);
      Matcher SerialMatch = SerialPattern.matcher(respBody);
      
      // Create an issue if we match any of the indicators for XXE vulnerabilities
      if (XxeMatch.find()) {
        List<int[]> XxeMatches = getMatches(messageInfo.getResponse(), XxeMatch.group(0).getBytes());
        if (XxeMatches.size() > 0) {
          reportIssue(messageInfo, XxeMatches, "[IoV] XXE Indicator of Vulnerability", "The response contained the following text: " + XxeMatch.group(0), "Low", "Tentative");
        }
      }
      
      // Create an issue if we match any of the indicators for SQLi vulnerabilities
      if (SqlMatch.find()) {
        List<int[]> SqlMatches = getMatches(messageInfo.getResponse(), SqlMatch.group(0).getBytes());
        if (SqlMatches.size() > 0) {
          reportIssue(messageInfo, SqlMatches, "[IoV] SQLi Indicator of Vulnerability", "The response contained the following text: " + SqlMatch.group(0), "Low", "Tentative");
        }
      }
      
      // Create an issue if we match any of the indicators for Deserialization vulnerabilities
      if (SerialMatch.find()) {
        List<int[]> SerialMatches = getMatches(messageInfo.getResponse(), SerialMatch.group(0).getBytes());
        if (SerialMatches.size() > 0) {
          reportIssue(messageInfo, SerialMatches, "[IoV] Serialization Indicator of Vulnerability", "The response contained the following text: " + SerialMatch.group(0), "Low", "Tentative");
        }
      }
    }
  }
  
  // helper method to search a response for occurrences of a literal match string
  // and return a list of start/end offsets
  private List<int[]> getMatches(byte[] response, byte[] match) {
    List<int[]> matches = new ArrayList<int[]>();

    int start = 0;
    while (start < response.length) {
      start = extHelpers.indexOf(response, match, true, start, response.length);
      if (start == -1)
        break;
      matches.add(new int[] { start, start + match.length });
      start += match.length;
    }
        
    return matches;
  }
  
  // Create issues from the reported findings
  private IScanIssue reportIssue(IHttpRequestResponse baseRequestResponse, List<int[]>matches, String IssueName, String IssueMatch, String Severity, String Confidence) {
      IScanIssue issue = new CustomScanIssue(
          baseRequestResponse.getHttpService(),
          extHelpers.analyzeRequest(baseRequestResponse).getUrl(), 
          new IHttpRequestResponse[] { extCallbacks.applyMarkers(baseRequestResponse, null, matches) }, 
          IssueName,
          IssueMatch,
          Severity,
          Confidence
      );
      extCallbacks.addScanIssue(issue);
      return issue;
  }
  
  // Consolidate duplicate findings
  public int consolidateDuplicateIssues(IScanIssue existingIssue, IScanIssue newIssue) {
    // This method is called when multiple issues are reported for the same URL 
    // path by the same extension-provided check. The value we return from this 
    // method determines how/whether Burp consolidates the multiple issues
    // to prevent duplication
    //
    // Since the issue name is sufficient to identify our issues as different,
    // if both issues have the same name, only report the existing issue
    // otherwise report both issues
    if (existingIssue.getIssueName().equals(newIssue.getIssueName()))
      return -1;
    else return 0;
   }
}

class CustomScanIssue implements IScanIssue {
  private IHttpService httpService;
  private URL url;
  private IHttpRequestResponse[] httpMessages;
  private String name;
  private String detail;
  private String severity;
  private String confidence;

  public CustomScanIssue(IHttpService httpService, URL url, IHttpRequestResponse[] httpMessages, String name, String detail, String severity, String confidence) {
    this.httpService = httpService;
    this.url = url;
    this.httpMessages = httpMessages;
    this.name = name;
    this.detail = detail;
    this.severity = severity;
    this.confidence = confidence;
  }
    
  @Override
  public URL getUrl() {
    return url;
  }

  @Override
  public String getIssueName() {
    return name;
  }

  @Override
  public int getIssueType() {
    return 0;
  }

  @Override
  public String getSeverity() {
    return severity;
  }

  @Override
  public String getConfidence() {
    return confidence;
  }

  @Override
  public String getIssueBackground() {
    return null;
  }

  @Override
  public String getRemediationBackground() {
    return null;
  }

  @Override
  public String getIssueDetail() {
    return detail;
  }

  @Override
  public String getRemediationDetail() {
    return null;
  }

  @Override
  public IHttpRequestResponse[] getHttpMessages() {
    return httpMessages;
  }

  @Override
  public IHttpService getHttpService() {
    return httpService;
  }
}